# pu12月-1月学习记录

[TOC]

## 前言

在休养了一周后，我准备再次开启学习之旅，这次还是和上次一样采用按日记录。

我本想于12月5日建立git仓库，奈何部分文件过大出现上传问题，导致我要拖到6号才能完成。

这轮学习将与github同步记录，也同时是为了我的学习积极性。

我也会尝试克服期间遇到的种种困难。

正文记录将于6号开始。

由于师兄新增了每周上交学习记录(LaTex排版)，所以这个学习记录就留给自己看了，

还是每日更新，但在每周周末根据这份记录进行整理并编写.tex文件，上交.pdf文件。

## 正文

### 12月6日 Sun

#### Git

在处理好我的仓库(https://github.com/Allan-twelve/machine_learning)后，我学习了如何上传图片，并解决了图片在GitHub上不显示的问题，并尝试了在markdown文件中插入GitHub上的图片。

![test](https://raw.githubusercontent.com/Allan-twelve/learngit/master/picture_test.jpg)

之后又创建了一个photos仓库，为将来图片引用做好准备。

### 12月7日 Mon

#### LaTex

下载并安装了LaTex，学习了部分基本格式。

#### 线性代数

复习并做了两套综合卷，迎接明天的期末考试。

### 12月8日 Tue

#### 线性代数

学习并复习了线性代数

通过观看MIT线性代数复习并巩固了以下知识：

矩阵乘法(四种方法)：常规、列方法、行方法、列乘行。

逆矩阵：行列式不为零(非奇异矩阵)才存在，行列式为零时(奇异矩阵)不存在逆矩阵。

LU分解：将一个矩阵分为上三角阵与下三角阵相乘。

矩阵转置，向量空间，列空间和零空间(AX=0时X的所有解的集合所形成的空间)。

今日考试把基础解系和通解概念弄反了(反思)

#### python

学习了NumPy模块(python数据分析手册):

(引用时一般import numpy as np便于使用)

了解了python中数据的存储方式：是用c语言编写的利用指针和结构体进行存储的。

优点：是动态的，灵活性较高。(甚至可以在一个数组中存多种类型数据)

缺点：每个结构体都包含完整的信息，在很多时候是多余的。

而numpy中虽然数组类型是固定的(一般情况下只能是同类型数据)，但是更高效。

学习了NumPy中的数组：

了解了数组的属性：数组大小(所有元素的总长度)、形状(如3*4)，数据类型(int,float等)，字符长度等

对数组进行索引、切片(与python基础语法基本相同)

### 12月9日 Wed

#### python

NumPy中，对多维数组进行切片，以获取行和列，此时的切片数组是原数组的视图，若对其进行修改，会使原数组相应位置也发生改变(非副本视图)。

数组的复制(numpy.copy)(副本)。

利用numpy.reshape将数组变形，如:单行或单列数组变成矩阵。

利用numpy中concatenate，vstack和hstack等进行数组的拼接。(其实用concatenate都可以实现，但后者更简洁)：

```python
 numpy.vstack([array1,array2])
 numpy.concatenate([array1,array2])
 #以上两个等价
 numpy.hstack([array1,array2])
 numpy.concatenate([array1,array2],axis = 1)
 #以上两个等价
```

以及数组的分裂(split)，分裂是以输入的值为下标作为另一个新数组的首元素，

如：

```python
 x = [1,2,3,4]
 x1,x2 = np.split(x,[2])
```

此时x1 = [1,2], x2 = [3,4]

以上的对数组操作可以混合使用，灵活使用以满足不同的需求。

### 12月10日 Thurs

#### python

NumPy模块的学习：

python中一些循环耗时过长，而用向量的方式进行计算可以有效地提高代码运行效率。

了解了numpy中的通用函数(包括四则运算、绝对值、三角函数以及指数对数等)

对数组进行运算，实际上就是分别对数组中每一个元素进行运算，再返回一个新的(运算后的)数组。

利用out可以将运算后数组指定输出到想要储存的位置(包括数组切片的视图，从而修改数组的部分元素)：

```python
 x = numpy.arange(4)  #创建一个数组
 y = numpy.empty(4)  #再创建一个空的等长数组
#y = numpy.empty(len(x)) 也可以这样
 np.multiply(x, 10, out=y) #指定输出到y
 print(y) 
#结果[ 0. 10. 20. 30. 40.]
```

聚合:用reduce(之前学过的高阶函数进行累积计算)返回一个最终计算结果。

外积:(outer)将两组数组所有数的两两组合进行运算，并把所有结果都返回。

如:

```python
np.multiply.outer([1,2,3], [1,2,3])
```

会得到:

```python
array([[1,2,3],
[2,4,6],
[3,6,9]])
```

过程实际上是:

```python
array([[1*1,1*2,1*3],
[2*1,2*2,2*3],
[3*1,3*2,3*3]])
```

### 12月11日 Fri

#### LaTex

学习了LaTex的基础语法，了解了它的常用的控制序列的格式，可以掌握基本排版文章的水平。

基础排版格式：

```latex
\documentclass[UTF8]{ctexart} %文档类别说明
\usepackage{amsmath} %可以通过\usepackage引入宏包，类似import
\title{hello,world} %标题
\author{Allan} %作者名
\date{\today} %日期(\today可以生成当前日期)
\begin{document} %与\end配对，中间为环境，此处环境为(document)
\maketitle %生成导言区中的标题等
\tableofcontents %(放在maketitle后)可生成目录
\section{这一级标题}
内容1
\subsection{这是二级标题}
内容2
\paragraph{段落}
内容3
\subparagraph{这是二级段落}
内容4
\subsubsection{这是三级标题}
内容5
\end{document}
```

上面通过\usepackage导入(amsmath)宏包以引入数学功能，从而进行数学公式的插入与使用。

生成的pdf视图：

![](https://raw.githubusercontent.com/Allan-twelve/photos/master/latex%E6%B5%8B%E8%AF%951.jpg)

具体的数学公式用法待使用时再去学习。

### 12月12日 Sat

无

### 12月13日 Sun

进行知识的整合，复习并回忆本周所学的知识，并整理出latex文档，生成本周学习记录的pdf文件。

### 12月14日 Mon

本周开始的学习，由于偏向于实用性，增加了列举代码的量。

#### python

**NumPy学习：**

- 聚合(最小值、最大值等)：

```python
numpy.sum() #求和

numpy.max() #最大值

numpy.min() #最小值
```

注:以上numpy模块中的代码效率都比python的自带函数要高很多。

- 多维度聚合：

numpy的聚合可以对高维数组进行操作。

如:

```python
A = numpy.random.random((3, 4)) 

 print(A)  # 生成一个3*4的高维数组

[[ 0.8967576 0.03783739 0.75952519 0.06682827] 

 [ 0.8354065 0.99196818 0.19544769 0.43447084] 

 [ 0.66859307 0.15038721 0.37911423 0.6687194]]
```

利用axis改变轴向进行不同的操作：

如取最小值:

```python
A.min(axis=0) # 会从每一列找出最小值并将这列折叠成这一个元素

array([ 0.66859307, 0.03783739, 0.19544769, 0.06682827]) # 结果示意
```

取最大值axis=1示例： 

```python
 A.max(axis=1) # 同理，按行取最大值

 array([ 0.8967576 , 0.99196818, 0.6687194])
```

- 数组计算：广播

例子是最好理解的：

```python
a = numpy.array([0,1,2])

a + 3

array([3,4,5])
```

可以认为对这个3进行的操作，就是一种广播。

下面是一种更加复杂的：

```python
 a = numpy.arange(3) 

 b = numpy.arange(3)[:, numpy.newaxis] #类似将a进行了矩阵转置

 print(a) 

 print(b) 

[0 1 2] 

[[0] 
 [1] 
 [2]] 
```

 若进行a + b，会输出什么呢？

没错，和我想的一模一样： 

```python
array([[0, 1, 2], 
       [1, 2, 3], 
       [2, 3, 4]])
```

### 12月15日 Tue

#### python

**NumPy学习**

- 广播的三个规则(理解为主，不多赘述)
  > - 规则 1：如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补 1。
  > - 规则 2：如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为 1 的维度扩展以匹配另外一个数组的形状。
  > - 规则 3：如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于 1，那么会引发异常。

如上一个例子:

```python
 a = numpy.arange(3) 

 b = numpy.arange(3)[:, numpy.newaxis]

 print(a) 

 print(b) 

[0 1 2] 

[[0] 
 [1] 
 [2]] 

a + b
```

根据三条规则，a + b会自动兼容

```python
array([[0 1 2],  # a
       [0,1,2],
       [0,1,2]])

array([[0,0,0],  # b
       [1,1,1],
       [2,2,2]])

a + b     # 相当于这两个数组相加(此时等维度)

array([[0, 1, 2],   # a + b的结果
       [1, 2, 3], 
       [2, 3, 4]])
```

部分则不满足规则，不能进行广播：

```python
array([[1 1],   # a
       [1 1],
       [1 1]])

array([0 1 2])  # b
#此时a + b会出现错误
```

广播规则可用于任意二进制通用函数。(四则运算，绝对值，乘方对数等都行)

广播具有广泛的应用。(数组的归一化，绘制二维函数等)

- 布尔值与逻辑运算符的运用(挺有用的)

可对一个数组(可以是多维的)进行逻辑判断，返回由布尔值组成的数组(相同形状)

如：

```python
x = numpy.array([1, 2, 3, 4, 5]) 

x < 3 

array([True, True, False, False, False], dtype=bool) 
```

可用numpy.count_nonzero统计数组中True的数量，也可以用numpy.sum(因为True可视作1，False可视作0)。  (numpy.sum比sum高效)

也可以使用&，|，^，~(与，或，异或，非)等逻辑运算符和布尔值综合运用。

有了以上方法，就可以对一组数据进行统计了。
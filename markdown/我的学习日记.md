# 12月-1月学习记录

[TOC]

## 前言

在休养了一周后，我准备再次开启学习之旅，这次还是和上次一样采用按日记录。

我本想于12月5日建立git仓库，奈何部分文件过大出现上传问题，导致我要拖到6号才能完成。

这轮学习将与github同步记录，也同时是为了我的学习积极性。

我也会尝试克服期间遇到的种种困难。

正文记录将于6号开始。

由于师兄新增了每周上交学习记录(LaTex排版)，所以这个学习记录就留给自己看了，

还是每日更新，但在每周周末根据这份记录进行整理并编写.tex文件，上交.pdf文件。

## 正文

### 12月6日 Sun

#### Git

在处理好我的仓库(https://github.com/Allan-twelve/machine_learning)后，我学习了如何上传图片，并解决了图片在GitHub上不显示的问题，并尝试了在markdown文件中插入GitHub上的图片。

![test](https://raw.githubusercontent.com/Allan-twelve/learngit/master/picture_test.jpg)

之后又创建了一个photos仓库，为将来图片引用做好准备。

### 12月7日 Mon

#### LaTex

下载并安装了LaTex，学习了部分基本格式。

#### 线性代数

复习并做了两套综合卷，迎接明天的期末考试。

### 12月8日 Tue

#### 线性代数

学习并复习了线性代数

通过观看MIT线性代数复习并巩固了以下知识：

矩阵乘法(四种方法)：常规、列方法、行方法、列乘行。

逆矩阵：行列式不为零(非奇异矩阵)才存在，行列式为零时(奇异矩阵)不存在逆矩阵。

LU分解：将一个矩阵分为上三角阵与下三角阵相乘。

矩阵转置，向量空间，列空间和零空间(AX=0时X的所有解的集合所形成的空间)。

今日考试把基础解系和通解概念弄反了(反思)

#### python

学习了NumPy模块(python数据分析手册):

(引用时一般import numpy as np便于使用)

了解了python中数据的存储方式：是用c语言编写的利用指针和结构体进行存储的。

优点：是动态的，灵活性较高。(甚至可以在一个数组中存多种类型数据)

缺点：每个结构体都包含完整的信息，在很多时候是多余的。

而numpy中虽然数组类型是固定的(一般情况下只能是同类型数据)，但是更高效。

学习了NumPy中的数组：

了解了数组的属性：数组大小(所有元素的总长度)、形状(如3*4)，数据类型(int,float等)，字符长度等

对数组进行索引、切片(与python基础语法基本相同)

### 12月9日 Wed

#### python

NumPy中，对多维数组进行切片，以获取行和列，此时的切片数组是原数组的视图，若对其进行修改，会使原数组相应位置也发生改变(非副本视图)。

数组的复制(numpy.copy)(副本)。

利用numpy.reshape将数组变形，如:单行或单列数组变成矩阵。

利用numpy中concatenate，vstack和hstack等进行数组的拼接。(其实用concatenate都可以实现，但后者更简洁)：

```python
 numpy.vstack([array1,array2])
 numpy.concatenate([array1,array2])
 #以上两个等价
 numpy.hstack([array1,array2])
 numpy.concatenate([array1,array2],axis = 1)
 #以上两个等价
```

以及数组的分裂(split)，分裂是以输入的值为下标作为另一个新数组的首元素，

如：

```python
 x = [1,2,3,4]
 x1,x2 = np.split(x,[2])
```

此时x1 = [1,2], x2 = [3,4]

以上的对数组操作可以混合使用，灵活使用以满足不同的需求。

### 12月10日 Thurs

#### python

NumPy模块的学习：

python中一些循环耗时过长，而用向量的方式进行计算可以有效地提高代码运行效率。

了解了numpy中的通用函数(包括四则运算、绝对值、三角函数以及指数对数等)

对数组进行运算，实际上就是分别对数组中每一个元素进行运算，再返回一个新的(运算后的)数组。

利用out可以将运算后数组指定输出到想要储存的位置(包括数组切片的视图，从而修改数组的部分元素)：

```python
 x = numpy.arange(4)  #创建一个数组
 y = numpy.empty(4)  #再创建一个空的等长数组
#y = numpy.empty(len(x)) 也可以这样
 np.multiply(x, 10, out=y) #指定输出到y
 print(y) 
#结果[ 0. 10. 20. 30. 40.]
```

聚合:用reduce(之前学过的高阶函数进行累积计算)返回一个最终计算结果。

外积:(outer)将两组数组所有数的两两组合进行运算，并把所有结果都返回。

如:

```python
np.multiply.outer([1,2,3], [1,2,3])
```

会得到:

```python
array([[1,2,3],
[2,4,6],
[3,6,9]])
```

过程实际上是:

```python
array([[1*1,1*2,1*3],
[2*1,2*2,2*3],
[3*1,3*2,3*3]])
```

### 12月11日 Fri

#### LaTex

学习了LaTex的基础语法，了解了它的常用的控制序列的格式，可以掌握基本排版文章的水平。

基础排版格式：

```latex
\documentclass[UTF8]{ctexart} %文档类别说明
\usepackage{amsmath} %可以通过\usepackage引入宏包，类似import
\title{hello,world} %标题
\author{Allan} %作者名
\date{\today} %日期(\today可以生成当前日期)
\begin{document} %与\end配对，中间为环境，此处环境为(document)
\maketitle %生成导言区中的标题等
\tableofcontents %(放在maketitle后)可生成目录
\section{这一级标题}
内容1
\subsection{这是二级标题}
内容2
\paragraph{段落}
内容3
\subparagraph{这是二级段落}
内容4
\subsubsection{这是三级标题}
内容5
\end{document}
```

上面通过\usepackage导入(amsmath)宏包以引入数学功能，从而进行数学公式的插入与使用。

生成的pdf视图：

![](https://raw.githubusercontent.com/Allan-twelve/photos/master/latex%E6%B5%8B%E8%AF%951.jpg)

具体的数学公式用法待使用时再去学习。

### 12月12日 Sat

无

### 12月13日 Sun

进行知识的整合，复习并回忆本周所学的知识，并整理出latex文档，生成本周学习记录的pdf文件。

### 12月14日 Mon

本周开始的学习，由于偏向于实用性，增加了列举代码的量。

#### python

**NumPy学习：**

- 聚合(最小值、最大值等)：

```python
numpy.sum() #求和

numpy.max() #最大值

numpy.min() #最小值
```

注:以上numpy模块中的代码效率都比python的自带函数要高很多。

- 多维度聚合：

numpy的聚合可以对高维数组进行操作。

如:

```python
A = numpy.random.random((3, 4)) 

 print(A)  # 生成一个3*4的高维数组

[[ 0.8967576 0.03783739 0.75952519 0.06682827] 

 [ 0.8354065 0.99196818 0.19544769 0.43447084] 

 [ 0.66859307 0.15038721 0.37911423 0.6687194]]
```

利用axis改变轴向进行不同的操作：

如取最小值:

```python
A.min(axis=0) # 会从每一列找出最小值并将这列折叠成这一个元素

array([ 0.66859307, 0.03783739, 0.19544769, 0.06682827]) # 结果示意
```

取最大值axis=1示例： 

```python
 A.max(axis=1) # 同理，按行取最大值

 array([ 0.8967576 , 0.99196818, 0.6687194])
```

- 数组计算：广播

例子是最好理解的：

```python
a = numpy.array([0,1,2])

a + 3

array([3,4,5])
```

可以认为对这个3进行的操作，就是一种广播。

下面是一种更加复杂的：

```python
 a = numpy.arange(3) 

 b = numpy.arange(3)[:, numpy.newaxis] #类似将a进行了矩阵转置

 print(a) 

 print(b) 

[0 1 2] 

[[0] 
 [1] 
 [2]] 
```

 若进行a + b，会输出什么呢？

没错，和我想的一模一样： 

```python
array([[0, 1, 2], 
       [1, 2, 3], 
       [2, 3, 4]])
```

### 12月15日 Tue

#### python

**NumPy学习**

- 广播的三个规则(理解为主，不多赘述)
  > - 规则 1：如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补 1。
  > - 规则 2：如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为 1 的维度扩展以匹配另外一个数组的形状。
  > - 规则 3：如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于 1，那么会引发异常。

如上一个例子:

```python
 a = numpy.arange(3) 

 b = numpy.arange(3)[:, numpy.newaxis]

 print(a) 

 print(b) 

[0 1 2] 

[[0] 
 [1] 
 [2]] 

a + b
```

根据三条规则，a + b会自动兼容

```python
array([[0 1 2],  # a
       [0,1,2],
       [0,1,2]])

array([[0,0,0],  # b
       [1,1,1],
       [2,2,2]])

a + b     # 相当于这两个数组相加(此时等维度)

array([[0, 1, 2],   # a + b的结果
       [1, 2, 3], 
       [2, 3, 4]])
```

部分则不满足规则，不能进行广播：

```python
array([[1 1],   # a
       [1 1],
       [1 1]])

array([0 1 2])  # b
#此时a + b会出现错误
```

广播规则可用于任意二进制通用函数。(四则运算，绝对值，乘方对数等都行)

广播具有广泛的应用。(数组的归一化，绘制二维函数等)

- 布尔值与逻辑运算符的运用(挺有用的)

可对一个数组(可以是多维的)进行逻辑判断，返回由布尔值组成的数组(相同形状)

如：

```python
x = numpy.array([1, 2, 3, 4, 5]) 

x < 3 

array([True, True, False, False, False], dtype=bool) 
```

可用numpy.count_nonzero统计数组中True的数量，也可以用numpy.sum(因为True可视作1，False可视作0)。  (numpy.sum比sum高效)

也可以使用&，|，^，~(与，或，异或，非)等逻辑运算符和布尔值综合运用。

有了以上方法，就可以对一组数据进行统计了。

### 12月16日 Wed

#### python

- 利用布尔数组进行掩码操作

```python
x = numpy.array([[5, 0, 3, 3], 

              [7, 9, 3, 5], 

              [2, 4, 7, 6]])

x[x > 3]  # 以布尔值索引

array([5, 7, 9, 5, 4, 7, 6]) # 输出结果
```

这个数组的每个元素就是布尔数组中对应True的值。

```python
array([[ True, False, False, False],
       [ True,  True, False,  True],
       [False,  True,  True,  True]])
```

这个布尔数组就是x的掩码。

关于逻辑运算符(and 和 or 是对于整体进行比较的，而| 和 & 是对单一比特或字节的)

- 花哨的索引

索引可以用数组的形式：

```python
rand = numpy.random.RandomState(10)

x = rand.randint(20, size=10)

print(x)

[ 9,  4, 15,  0, 17, 16, 17,  8,  9,  0]

x[[3,4,5]]  # 类似于[x[3],x[4],x[5]]

array([ 0, 17, 16])

x[numpy.array([[3,4],[5,6]])]   # 高维数组也可以进行索引

array([[ 0, 17],    # 与索引的数组形状相同
       [16, 17]])
```

对多维也适用：

```python
 x = numpy.arange(12).reshape((3, 4)) 

 x

 array([[ 0, 1, 2, 3],   # 一个3*4的二维数组

        [ 4, 5, 6, 7], 

        [ 8, 9, 10, 11]])
 #1.
 x[1,1]   # 常规索引

 5
 #2.
 x[[1,2],[1,3]]   # 类似于[x[1,1],x[2,3]](两个索引值一一对应)

 array([ 5, 11])
 #3.  
 x[numpy.array([[0,1],[1,2]]),numpy.array([[2,3],[1,0]])]
 #举个数组索引例子(说明了形状不变)

 array([[2, 7]，        
        [5, 8]])
 #实质是(下面的只是列表，用于理解上述过程)

 #[x[0,2],x[1,3],
 # x[1,1],x[2,0]]
```

索引同样满足广播规则：

```python
a = numpy.array([[2],   # 一个三维列向量
                 [1],
                 [0]])

b = numpy.array([2,1,0])  # 一个三维向量

c = numpy.array([[2,1,0]])  # 一个三维行向量

x[a,b]   # 这里输入x[a,c]输出结果也是相同的

array([[10,  9,  8],
       [ 6,  5,  4],
       [ 2,  1,  0]])

d = numpy.array([[2,2,2],   # 根据广播规则，a在x的索引中等效于d
                 [1,1,1],
                 [0,0,0]])

e = numpy.array([[2,1,0],   # b等效于e
                 [2,1,0],
                 [2,1,0]])

x[d,e]

array([[10,  9,  8],   # 可见结果是相同的
       [ 6,  5,  4],
       [ 2,  1,  0]])

x[::-1,2::-1]  # 用切片操作也可以实现

array([[10,  9,  8],
       [ 6,  5,  4],
       [ 2,  1,  0]])
```

可以将花哨的索引、切片、掩码等结合使用。(从而更加花里胡哨 /狗头)

- reshape的补充

以上文的x为例：

```python
x
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

x.reshape((4,3))   # 一般用法(写一个括号效果也一样：x.reshape(4,3))

x.reshape(2,-1)   #此处-1为不确定值，会根据另一个维度信息进行自动补充

array([[ 0,  1,  2,  3,  4,  5],   # 此处行为2，因此自动计算为6列
       [ 6,  7,  8,  9, 10, 11]])

x.reshape(-1,6)   #同理，行数不确定(这里输出与上面相同)
```

order参数：

有A，F，C三种，举例如下：

```python
x

array([[ 0,  1,  2,  3],   # 原数组
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

x.reshape((3,4),order=C)

array([[ 0,  1,  2],   # 按行读取，按行写入
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])

x.reshape((3,4),order=C)

array([[ 0,  5, 10],   # 按列读取，按列写入
       [ 4,  9,  3],
       [ 8,  2,  7],
       [ 1,  6, 11]])

x.reshape((3,4),order=F)   # 根据x数组的储存方式而定
```

### 12月17日

#### python

今天学习了numpy的各种索引的实例。

```python
x = numpy.zeros(5) 

x

array([0.,0.,0.,0.,0.])

x[[0,0]] = [1,3]   # 利用花哨的索引赋值

print(x)

[3. 0. 0. 0. 0.]   #此时先进行x[0] = 1,再进行x[0] = 3.

x[[1,2,2,3,3,3]] += 1   # 花哨的索引运算

print(x)           # 等效于x[…] = x[…] + 1 ([…]中省略了数组)

[3. 1. 1. 1. 0.]   # 由于先进行x[…] + 1运算出结果，再进行赋值
                   # 所以多次赋值结果仍不变
numpy.add.at(x,[1,2,2,3,3,3],1)   # 利用at可使进行累积计算

print(x)

[3. 2. 3. 4. 0.] 
```

学习了解到：一个对大数据集非常有效的算法并不总是小数据集的最佳选择，反之同理。

数组的排序有：插入排序、选择排序、归并排序、快速排序、冒泡排序等

选择排序用python实现的例子：

```python
import numpy as np
def selectionSort(x):
	for i in range(len(x)):
    	j = i + np.argmin(x[i:])  # argmin返回最小值的下标(索引值)
        (x[i],x[j]) = (x[j],x[i])
    return x
```

python内置了sort和sorted函数，但同样的，numpy.sort拥有更高的效率。

numpy.sort还可以使用axis=1或axis=0来改变排序的行或列。

numpy.argsort可返回排序后的下标(索引值)，从而可以通过一次花哨的索引，来生成排序后的数组。

np.partition可以将数组从排第n小的分隔成两部分(左边是从最小的一直到第n小，右边是剩下的)，两边都是随意排列的(无序)。(axis一样适用)

例如：

```python
x = numpy.array([4, 3, 7, 6, 1, 5, 2]) 

numpy.partition(x, 3) 

array([3, 2, 1, 4, 7, 5, 6])
```

### 12月18日

#### python

- 一个计算k个最近邻的例子(简化版)

我们目的是：取随机分布在二维平面上的5个点，将其中每个点与其最近的1(可以是k)个点连线。(计算它们之间的距离)

```python
import numpy as np

rand = np.random.RandomState(42) 

x = rand.rand(5, 2)    # 创建5个在二维平面上的点
```

![看不了就翻墙，反正我看得到](https://raw.githubusercontent.com/Allan-twelve/photos/master/Figure_1.png)

```python
# np.newaxis的作用是创建出一个新的维度
dif = x[:, np.newaxis, :] - x[np.newaxis, :, :] # 求出每对点的差值
```

具体实现原理以及过程理解：

```python
x[:, np.newaxis, :]   # 将x拓展至三维

array([[[0.02058449, 0.96990985]],   
       [[0.83244264, 0.21233911]],
       [[0.18182497, 0.18340451]],
       [[0.30424224, 0.52475643]],
       [[0.43194502, 0.29122914]]])
# 可以将一个中括号[]视作一个维度，这里array([[[中有三层：
# 第一个(最外层)的'[]'里面面有五个[…]，所以第一维为5
# 类推，第二个(单独的一个)'[]'中只有一个[…]，第二维为1
# 最里面的[]中显然两个元素，因此第三维为2
x[:, np.newaxis, :].shape  # 验证结果

(5, 1, 2)   # 根本原因是np.newaxis在第二维处，新增了维度(长度为1)
# 同理
x[np.newaxis, :, :]
array([[[0.02058449, 0.96990985],
        [0.83244264, 0.21233911],
        [0.18182497, 0.18340451],
        [0.30424224, 0.52475643],
        [0.43194502, 0.29122914]]])

x[np.newaxis, :, :].shape
(1, 5, 2)
```

根据广播规则(5,1,2)与(1,5,2)会自动补充成两个(5,5,2)运算

因此：

```python
dif.shape
(5, 5, 2)

dif   # 它是一个五个点分别与这五个点的距离之差
array([[[ 0.        ,  0.        ],
        [-0.81185815,  0.75757074],
        [-0.16124047,  0.78650534],
        [-0.28365775,  0.44515342],
        [-0.41136052,  0.67868071]],

       [[ 0.81185815, -0.75757074],
        [ 0.        ,  0.        ],
        [ 0.65061767,  0.0289346 ],
        [ 0.5282004 , -0.31241732],
        [ 0.40049762, -0.07889003]],

       [[ 0.16124047, -0.78650534],
        [-0.65061767, -0.0289346 ],
        [ 0.        ,  0.        ],
        [-0.12241728, -0.34135192],
        [-0.25012005, -0.10782463]],

       [[ 0.28365775, -0.44515342],
        [-0.5282004 ,  0.31241732],
        [ 0.12241728,  0.34135192],
        [ 0.        ,  0.        ],
        [-0.12770278,  0.23352729]],

       [[ 0.41136052, -0.67868071],
        [-0.40049762,  0.07889003],
        [ 0.25012005,  0.10782463],
        [ 0.12770278, -0.23352729],
        [ 0.        ,  0.        ]]])

sq = dif ** 2   # 众所周知两点间距离公式是sqrt(x^2+y^2)
sq              # 此时sq的第三维相当于[x^2,y^2]
array([[[0.        , 0.        ],
        [0.65911365, 0.57391343],
        [0.02599849, 0.61859065],
        [0.08046172, 0.19816157],
        [0.16921748, 0.46060751]],

       [[0.65911365, 0.57391343],
        [0.        , 0.        ],
        [0.42330336, 0.00083721],
        [0.27899566, 0.09760458],
        [0.16039835, 0.00622364]],

       [[0.02599849, 0.61859065],
        [0.42330336, 0.00083721],
        [0.        , 0.        ],
        [0.01498599, 0.11652113],
        [0.06256004, 0.01162615]],

       [[0.08046172, 0.19816157],
        [0.27899566, 0.09760458],
        [0.01498599, 0.11652113],
        [0.        , 0.        ],
        [0.016308  , 0.054535  ]],

       [[0.16921748, 0.46060751],
        [0.16039835, 0.00622364],
        [0.06256004, 0.01162615],
        [0.016308  , 0.054535  ],
        [0.        , 0.        ]]])
#理所当然下一步计算下x^2与y^2的和
dist = sq.sum(-1)  #等价于:sq.sum(2),sq.sum(axis=2),sq.sum(axis=-1)
dist
array([[0.        , 1.23302708, 0.64458914, 0.27862329, 0.62982499],
       [1.23302708, 0.        , 0.42414057, 0.37660024, 0.16662198],
       [0.64458914, 0.42414057, 0.        , 0.13150712, 0.07418619],
       [0.27862329, 0.37660024, 0.13150712, 0.        , 0.07084299],
       [0.62982499, 0.16662198, 0.07418619, 0.07084299, 0.        ]])
# 可见该矩阵对角线上的值都为0。(由于排版显示问题，建议全屏markdown文件)
# 接下来利用argpartition分隔矩阵并求出前k近的点。
k = 1  # 求出的最近的k个点(一个点)
nearest = np.argpartition(dist, k + 1, axis=1)
# 因为矩阵中包含每个点自己，所以k + 1
nearest
array([[0, 3, 4, 1, 2],
       [1, 4, 3, 2, 0],
       [2, 4, 3, 0, 1],
       [3, 4, 2, 0, 1],
       [4, 3, 2, 1, 0]], dtype=int64)
```

![](https://raw.githubusercontent.com/Allan-twelve/photos/master/Figure_2.png)

至此，目标达成。